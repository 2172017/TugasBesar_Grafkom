<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Route Explorer â€” Visual Dijkstra / A*</title>
		<style src="css/style.css"></style>
		<script src="js/dijkstra.js"></script>
		<script src="js/grafika_lib.js"></script>
		<script src="js/rendering.js"></script>
		<script src="js/transformasi_matriks.js"></script>
	</head>
	<body>
		<div id="left">
			<h3>Route Explorer</h3>
			<div class="controls">
				<button id="btnAddNode" class="btn small">Add Node</button>
				<button id="btnAddEdge" class="btn small">Add Edge</button>
				<button id="btnMove" class="btn small">Move</button>
				<button id="btnDelete" class="btn small">Delete</button>
			</div>

			<label
				>Algorithm
				<select id="algo">
					<option value="dijkstra">Dijkstra</option>
					<option value="astar">A* (Euclidean)</option>
				</select>
			</label>

			<div style="margin-top: 8px">
				<button id="btnStep" class="btn">Step</button>
				<button id="btnRun" class="btn">Run</button>
				<button id="btnReset" class="btn">Reset</button>
			</div>

			<label
				>Speed
				<input id="speed" type="range" min="50" max="1000" value="250" />
			</label>

			<label><input type="checkbox" id="showHeat" /> Show cost heatmap</label>
			<label
				><input type="checkbox" id="showSpeed" /> Show "speed" overlay</label
			>

			<div class="info">
				Click canvas to add node (when Add Node active).<br />
				Click two nodes to add edge (when Add Edge active).<br />
				Ctrl+Click node = set source. Alt+Click node = set target.<br />
				Use Move to drag nodes. Delete to remove node/edge.
			</div>

			<hr />
			<div id="status" class="info">Status: idle</div>
			<pre
				id="log"
				style="
					height: 160px;
					overflow: auto;
					background: #fff;
					padding: 6px;
					border: 1px solid #eee;
				"
			></pre>
		</div>

		<div id="canvas-wrap">
			<canvas id="c" width="900" height="700"></canvas>
		</div>

		<script>
			const canvasKita = document.querySelector("#c");
			const ctx = canvasKita.getContext("2d");

			class Graph {
				constructor() {
					this.nodes = [];
					this.edges = [];
					this.nextId = 1;
				}
				addNode(x, y) {
					const n = { id: this.nextId++, x, y };
					this.nodes.push(n);
					return n;
				}
				removeNode(id) {
					this.edges = this.edges.filter((e) => e.a !== id && e.b !== id);
					this.nodes = this.nodes.filter((n) => n.id !== id);
				}
				addEdge(a, b, weight) {
					if (a === b) return;
					if (
						this.edges.find(
							(e) => (e.a === a && e.b === b) || (e.a === b && e.b === a)
						)
					)
						return;
					const w =
						weight === undefined
							? distance(this.getNode(a), this.getNode(b))
							: weight;
					this.edges.push({ a, b, w });
				}
				removeEdgeBetween(a, b) {
					this.edges = this.edges.filter(
						(e) => !((e.a === a && e.b === b) || (e.a === b && e.b === a))
					);
				}
				getNode(id) {
					return this.nodes.find((n) => n.id === id);
				}
				neighbors(id) {
					return this.edges
						.filter((e) => e.a === id || e.b === id)
						.map((e) => ({ id: e.a === id ? e.b : e.a, w: e.w }));
				}
			}

			class TinyPQ {
				constructor() {
					this.arr = [];
				}
				push(obj) {
					this.arr.push(obj);
					this.arr.sort((a, b) => a.cost - b.cost);
				}
				pop() {
					return this.arr.shift();
				}
				size() {
					return this.arr.length;
				}
			}

			const graph = new Graph();
			graph.addNode(120, 120);
			graph.addNode(300, 100);
			graph.addNode(520, 160);
			graph.addNode(200, 300);
			graph.addNode(480, 340);
			graph.addEdge(1, 2);
			graph.addEdge(2, 3);
			graph.addEdge(1, 4);
			graph.addEdge(4, 5);
			graph.addEdge(3, 5);
			graph.addEdge(2, 4);

			let mode = "addnode";
			let picked = null;
			let dragging = null;
			let sourceId = null,
				targetId = null;

			const btnAddNode = document.getElementById("btnAddNode");
			const btnAddEdge = document.getElementById("btnAddEdge");
			const btnMove = document.getElementById("btnMove");
			const btnDelete = document.getElementById("btnDelete");
			const btnStep = document.getElementById("btnStep");
			const btnRun = document.getElementById("btnRun");
			const btnReset = document.getElementById("btnReset");
			const algoSel = document.getElementById("algo");
			const status = document.getElementById("status");
			const log = document.getElementById("log");
			const speedEl = document.getElementById("speed");
			const showHeat = document.getElementById("showHeat");

			btnAddNode.onclick = () => setMode("addnode");
			btnAddEdge.onclick = () => setMode("addedge");
			btnMove.onclick = () => setMode("move");
			btnDelete.onclick = () => setMode("delete");

			canvasKita.addEventListener("mousedown", (e) => {
				const r = canvasKita.getBoundingClientRect();
				const x = e.clientX - r.left;
				const y = e.clientY - r.top;
				const hit = graph.nodes.find((n) => distance(n, { x, y }) < 14);
				if (mode === "addnode" && !hit) {
					const n = graph.addNode(x, y);
					logMsg("node " + n.id + " added");
				} else if (mode === "addedge") {
					if (hit) {
						if (!picked) {
							picked = hit.id;
							logMsg("picked " + picked + " for edge");
						} else {
							graph.addEdge(picked, hit.id);
							logMsg("edge " + picked + "-" + hit.id);
							picked = null;
						}
					}
				} else if (mode === "move") {
					if (hit) {
						dragging = hit;
					}
				} else if (mode === "delete") {
					if (hit) {
						graph.removeNode(hit.id);
						logMsg("node " + hit.id + " removed");
					} else {
						const nearEdge = findEdgeNearPoint(x, y);
						if (nearEdge) {
							graph.removeEdgeBetween(nearEdge.a, nearEdge.b);
							logMsg("edge " + nearEdge.a + "-" + nearEdge.b + " removed");
						}
					}
				}
				if (hit) {
					if (e.ctrlKey) {
						sourceId = hit.id;
						logMsg("source set " + sourceId);
					}
					if (e.altKey) {
						targetId = hit.id;
						logMsg("target set " + targetId);
					}
				}
			});

			canvasKita.addEventListener("mousemove", (e) => {
				if (dragging) {
					const r = canvasKita.getBoundingClientRect();
					dragging.x = e.clientX - r.left;
					dragging.y = e.clientY - r.top;
				}
			});
			window.addEventListener("mouseup", () => {
				dragging = null;
			});

			let stepper = null;
			let runner = null;
			let lastPath = null;
			btnStep.onclick = () => {
				if (!sourceId || !targetId) {
					alert("set source (Ctrl+click) and target (Alt+click) first");
					return;
				}
				if (!stepper)
					stepper = createPathfinder(graph, sourceId, targetId, algoSel.value);
				const res = stepper.step();
				if (res.done) {
					if (res.path) {
						lastPath = res.path;
						status.textContent = "Status: done";
						render(res.path);
						logMsg("path found: " + res.path.join("->"));
					} else {
						status.textContent = "Status: finished: no path";
						render();
						logMsg("no path");
					}
					stepper = null;
				} else {
					status.textContent = "Status: stepping";
					render(res.visited || []);
				}
			};

			btnRun.onclick = () => {
				if (!sourceId || !targetId) {
					alert("set source and target first");
					return;
				}
				if (runner) {
					clearInterval(runner);
					runner = null;
					btnRun.textContent = "Run";
					return;
				}
				stepper = createPathfinder(graph, sourceId, targetId, algoSel.value);
				btnRun.textContent = "Stop";
				runner = setInterval(() => {
					const res = stepper.step();
					if (res.done) {
						clearInterval(runner);
						runner = null;
						btnRun.textContent = "Run";
						if (res.path) {
							lastPath = res.path;
							status.textContent = "Status: done";
							render(res.path);
							logMsg("path found: " + res.path.join("->"));
						} else {
							status.textContent = "Status: finished: no path";
							render();
							logMsg("no path");
						}
						stepper = null;
					} else {
						status.textContent = "Status: running";
						render(res.visited || []);
					}
				}, parseInt(speedEl.value));
			};

			btnReset.onclick = () => {
				stepper = null;
				runner && clearInterval(runner);
				runner = null;
				lastPath = null;
				sourceId = null;
				targetId = null;
				status.textContent = "Status: idle";
				render();
				logMsg("reset");
			};

			render();

			setInterval(() => {
				render(lastPath);
			}, 60);
		</script>
	</body>
</html>
